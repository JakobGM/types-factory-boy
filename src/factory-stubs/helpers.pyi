from typing import (
    Any,
    Callable,
    ContextManager,
    Iterator,
    Literal,
    TextIO,
    Type,
    TypeAlias,
    TypeVar,
)

T = TypeVar("T")
V = TypeVar("V")
_Strategy: TypeAlias = Literal["build", "create", "stub"]

from . import base, builder, declarations

def debug(logger: str = ..., stream: TextIO | None = ...) -> ContextManager[None]: ...
def make_factory(klass: T, **kwargs: Any) -> Type[base.Factory[T]]: ...
def build(klass: T, **kwargs: Any) -> T: ...
def build_batch(klass: T, size: int, **kwargs: Any) -> list[T]: ...
def create(klass: T, **kwargs: Any) -> T: ...
def create_batch(klass: T, size: int, **kwargs: Any) -> list[T]: ...
def stub(klass: T, **kwargs: Any) -> base.StubObject: ...
def stub_batch(klass: T, size: int, **kwargs: Any) -> base.StubObject: ...

# TODO: overload here
def generate(klass: T, strategy: _Strategy, **kwargs: Any) -> T | base.StubObject: ...

# TODO: overload here
def generate_batch(
    klass: T, strategy: _Strategy, size: int, **kwargs: Any
) -> list[T] | list[base.StubObject]: ...
def simple_generate(klass: T, create: bool, **kwargs: Any) -> T: ...
def simple_generate_batch(
    klass: T, create: bool, size: int, **kwargs: Any
) -> list[T]: ...
def lazy_attribute(
    func: Callable[[builder.Resolver], T]
) -> declarations.LazyAttribute[T]: ...
def iterator(func: Callable[[], Iterator[T]]) -> declarations.Iterator[T, T]: ...
def sequence(func: Callable[[int], T]) -> declarations.Sequence[T]: ...
def lazy_attribute_sequence(
    func: Callable[[builder.Resolver, int], T]
) -> declarations.LazyAttributeSequence[T]: ...
def container_attribute(
    func: Callable[[builder.Resolver, tuple[builder.Resolver, ...]], T]
) -> declarations.ContainerAttribute[T]: ...
def post_generation(
    fun: Callable[[T, bool, Any, ...], V]
) -> declarations.PostGeneration[T, V]: ...
